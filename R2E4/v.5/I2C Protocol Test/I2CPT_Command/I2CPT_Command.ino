// I2CPT_Command
// Runs on the SCU.
/*
 * Test Script for Protocol Which Transmits Motor Data found on Digital Inputs
 * over I2C.
 * For this test, the command chip (SCU)is not just transmitting the commands
 * but its also creating them with the AccelStepper library. In implementation,
 * these commands will be generated by grbl in the CPU (Arm Cortex).
*/

#include <Wire.h>

// Pod ID:
#define POD_ID  632

// Step Signal (Command Input Pins):]
// R2AdM6 v1 (m168p):
/*
  STPA - PD3 - 3
  DIRA - PD4 - 4
  ENA  - PD2 - 2
*/
#define STP_I 3
// Direction Signal:
#define DIR_I 4
// Enable Signal:
#define EN_I 2

void setup(){
  Wire.begin();

  pinMode(STP_I, INPUT);
  pinMode(DIR_I, INPUT);
  pinMode(EN_I, INPUT);

  delay(100);
}

void loop(){
  // Motor A:
  byte comm = generateMotorCommand(STP_I, DIR_I, EN_I);
  sendMotorCommand(POD_ID, comm);
  delayMicroseconds(1); // Command Processing Relief (Due to differential rates at Main and Pod Driver)
}


// Reads the motor command dictated by given step, direction, and enable input
// pins and returns a byte representing the command message where:
//  bit 0 -> STEP
//  bit 1 -> DIRECTION
//  bit 2 -> ENABLE
//  bit 3 -> if comm=111 -> set ID to next byte; else, requesting information.
byte generateMotorCommand(int stpi, int diri, int eni){
  // Read GPIO:
  bool stp = digitalRead(stpi);
  bool dir = digitalRead(diri);
  bool en = digitalRead(eni);

  // Generate Command:
  byte comm = stp | (dir << 1) | (en << 2);

return comm;
} // #generateMotorCommand

// Sends the Given Motor Command to the Motor with Address, mot_id, over I2C,
// where the command is one byte where:
//  bit 0 -> STEP
//  bit 1 -> DIRECTION
//  bit 2 -> ENABLE
//  bit 3 -> if comm=111 -> set ID to next byte; else, requesting information.
void sendMotorCommand(int mot_id, byte comm){
  Wire.beginTransmission(mot_id);
    Wire.write(comm);
  Wire.endTransmission(); // mot_id
} // #sendMotorCommand
