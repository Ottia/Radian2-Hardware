// I2CPT_Command
/*
 * Test Script for Protocol Which Transmits Motor Data found on Digital Inputs
 * over I2C.
 * For this test, the command chip (SCU) is not just transmitting the commands
 * but its also creating them with the AccelStepper library. In implementation,
 * these commands will be generated by grbl in the CPU (Arm Cortex).
*/

#include <Wire.h>
#include <EEPROM.h>

// Prefix for the Bus these Pods are Connected To:
#define POD_ID  632


// R2E4 v5:
/*
  STP - PD0 - 0
  DIR - PD1 - 1
  EN  - PD2 - 2
  MS1 - PD5 - 5
  MS2 - PB7 - 15
  MS3 - PB6 - 14
*/
#define STP_O 0
#define DIR_O 1
#define EN_O 2

#define MS1 5
#define MS2 15
#define MS3 14

void setup(){
  // Initialize Microstepping State:
  /* Allegro A5984 Step Settings:
    321 | Fraction
    000 | 1/1
    001 | 1/2
    010 | 1/16
    011 | 1/32
    100 | 1/1 (70% pwr)
    101 | 1/2 (70% pwr)
    110 | 1/4
    111 | 1/8
  */
  pinMode(MS1, OUTPUT);
    digitalWrite(MS1, 1);
  pinMode(MS2, OUTPUT);
    digitalWrite(MS2, 1);
  pinMode(MS3, OUTPUT);
    digitalWrite(MS3, 1);

  // Activate Driver:
  pinMode(STP_O, OUTPUT);
  pinMode(DIR_O, OUTPUT);
  pinMode(EN_O, OUTPUT);
    digitalWrite(EN_O, 0);

  // Set Direction:
  digitalWrite(DIR_O, 1);

  digitalWrite(STP_O, 1);

  int mot_id = POD_ID;
  Wire.begin(mot_id);
  Wire.onReceive(receiveEvent);

}

void loop(){

}

void receiveEvent(int N_bytes){
  while( Wire.available() ) { // loop through all but the last
    byte msg = Wire.read(); // receive byte
    commandMotor(msg);
  }
}

// Sends a Command to the Motor where the command, comm, is one byte where:
//  bit 0 -> STEP
//  bit 1 -> DIRECTION
//  bit 2 -> ENABLE
//  bit 3 -> if comm=111 -> set ID to next byte; else, requesting information.
void commandMotor(byte comm){
  bool stp = (comm & 0b1) != 0;
  bool dir = (comm & 0b10) != 0;
  bool en = (comm & 0b100) != 0;

  digitalWrite(STP_O, stp);
  digitalWrite(DIR_O, dir);
  digitalWrite(EN_O, en);
} // #commandMotor
