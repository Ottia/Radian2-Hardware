// I2CPT_Command
/*
 * Test Script for Protocol Which Transmits Motor Data found on Digital Inputs
 * over I2C.
 * For this test, the command chip (SCU)is not just transmitting the commands
 * but its also creating them with the AccelStepper library. In implementation,
 * these commands will be generated by grbl in the CPU (Arm Cortex).
*/

#include <Wire.h>

// Pod ID:
#define POD_ID  632

// Step Signal (Command Output/Input Pins):
#define STP_O 6
#define STP_I 7
// Direction Signal:
#define DIR_O 8
#define DIR_I 9
// Enable Signal:
#define EN_O 10
#define EN_I 11

void setup(){
  Wire.begin();

  pinMode(STP_O, OUTPUT);
  pinMode(DIR_O, OUTPUT);
  pinMode(EN_O, OUTPUT);

  pinMode(STP_I, INPUT);
  pinMode(DIR_I, INPUT);
  pinMode(EN_I, INPUT);

  delay(100);
}

void loop(){
  comm = generateMotorCommand(STP_I, DIR_I, EN_I);
  sendMotorCommand(POD_ID, comm);
}


// Reads the motor command dictated by given step, direction, and enable input
// pins and returns a byte representing the command message where:
//  bit 0 -> STEP
//  bit 1 -> DIRECTION
//  bit 2 -> ENABLE
//  bit 3 -> if comm=111 -> set ID to next byte; else, requesting information.
byte generateMotorCommand(stpi, diri, eni){
  // Read GPIO:
  stp = digitalRead(stpi);
  dir = digitalRead(diri);
  en = digitalRead(eni);

  // Generate Command:
  byte comm = stp | (dir << 1) | (en << 2);

return comm;
} // #generateMotorCommand

// Sends the Given Motor Command to the Motor with Address, mot_id, over I2C,
// where the command is one byte where:
//  bit 0 -> STEP
//  bit 1 -> DIRECTION
//  bit 2 -> ENABLE
//  bit 3 -> if comm=111 -> set ID to next byte; else, requesting information.
void sendMotorCommand(unsigned int mot_id, byte comm){
  Wire.beginTransmission(mot_id);
    Wire.write(comm);
  Wire.endTransmission(); // mot_id
} // #sendMotorCommand
